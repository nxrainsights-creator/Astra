import { onDocumentCreated, onDocumentUpdated } from 'firebase-functions/v2/firestore';
import { onSchedule } from 'firebase-functions/v2/scheduler';
import * as admin from 'firebase-admin';

admin.initializeApp();
const db = admin.firestore();

// ============================================
// TRIGGER 1: Auto-generate invoice on project creation
// ============================================
export const onProjectCreated = onDocumentCreated('projects/{projectId}', async (event) => {
  try {
    const projectData = event.data.data();
    const projectId = event.params.projectId;

    console.log(`New project created: ${projectId}`);

    // Check if invoice already exists for this project
    const existingInvoice = await db.collection('invoices')
      .where('projectId', '==', projectId)
      .limit(1)
      .get();

    if (!existingInvoice.empty) {
      console.log('Invoice already exists for this project');
      return null;
    }

    // Generate invoice number
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    const invoiceNumber = `INV-${year}${month}-${random}`;

    // Create invoice document
    const invoiceData = {
      invoiceNumber,
      projectId,
      clientId: projectData.clientId,
      amount: projectData.budget || 0,
      tax: 18,
      subtotal: projectData.budget || 0,
      total: (projectData.budget || 0) * 1.18,
      description: `Invoice for project: ${projectData.name}`,
      paymentStatus: 'pending',
      dueDate: projectData.endDate || null,
      createdAt: admin.firestore.Timestamp.now(),
      updatedAt: admin.firestore.Timestamp.now(),
      autoGenerated: true
    };

    await db.collection('invoices').add(invoiceData);
    console.log(`Auto-generated invoice: ${invoiceNumber}`);

    return { success: true, invoiceNumber };
  } catch (error) {
    console.error('Error in onProjectCreated:', error);
    return { success: false, error: error.message };
  }
});

// ============================================
// TRIGGER 2: Send notification on task assignment
// ============================================
export const onTaskCreated = onDocumentCreated('tasks/{taskId}', async (event) => {
  try {
    const taskData = event.data.data();
    const taskId = event.params.taskId;

    console.log(`New task created: ${taskId}`);

    // Get assigned user info
    const userDoc = await db.collection('users').doc(taskData.assignedTo).get();
    if (!userDoc.exists) {
      console.log('Assigned user not found');
      return null;
    }

    const userData = userDoc.data();

    // Create notification
    const notificationData = {
      userId: taskData.assignedTo,
      title: 'New Task Assigned',
      message: `You have been assigned a new task: "${taskData.title}"`,
      type: 'task',
      taskId,
      read: false,
      createdAt: admin.firestore.Timestamp.now()
    };

    await db.collection('notifications').add(notificationData);
    console.log(`Notification sent to ${userData.name}`);

    return { success: true, notificationSent: true };
  } catch (error) {
    console.error('Error in onTaskCreated:', error);
    return { success: false, error: error.message };
  }
});

// ============================================
// TRIGGER 3: Notify on task reassignment
// ============================================
export const onTaskUpdated = onDocumentUpdated('tasks/{taskId}', async (event) => {
  try {
    const beforeData = event.data.before.data();
    const afterData = event.data.after.data();
    const taskId = event.params.taskId;

    // Check if task was reassigned
    if (beforeData.assignedTo !== afterData.assignedTo) {
      console.log(`Task ${taskId} reassigned from ${beforeData.assignedTo} to ${afterData.assignedTo}`);

      // Get new assigned user info
      const userDoc = await db.collection('users').doc(afterData.assignedTo).get();
      if (!userDoc.exists) {
        console.log('New assigned user not found');
        return null;
      }

      const userData = userDoc.data();

      // Create notification for new assignee
      const notificationData = {
        userId: afterData.assignedTo,
        title: 'Task Reassigned to You',
        message: `Task "${afterData.title}" has been reassigned to you`,
        type: 'task',
        taskId,
        read: false,
        createdAt: admin.firestore.Timestamp.now()
      };

      await db.collection('notifications').add(notificationData);
      console.log(`Reassignment notification sent to ${userData.name}`);
    }

    // Check if task status changed to completed
    if (beforeData.status !== 'completed' && afterData.status === 'completed') {
      console.log(`Task ${taskId} marked as completed`);

      // Notify task assigner
      if (afterData.assignedBy) {
        const assignerDoc = await db.collection('users').doc(afterData.assignedBy).get();
        if (assignerDoc.exists) {
          const completionNotification = {
            userId: afterData.assignedBy,
            title: 'Task Completed',
            message: `Task "${afterData.title}" has been completed`,
            type: 'task',
            taskId,
            read: false,
            createdAt: admin.firestore.Timestamp.now()
          };

          await db.collection('notifications').add(completionNotification);
          console.log('Completion notification sent to assigner');
        }
      }
    }

    return { success: true };
  } catch (error) {
    console.error('Error in onTaskUpdated:', error);
    return { success: false, error: error.message };
  }
});

// ============================================
// TRIGGER 4: Update invoice status based on due date
// ============================================
export const checkOverdueInvoices = onSchedule('every day 00:00', async (event) => {
  try {
    console.log('Checking for overdue invoices...');
    const today = admin.firestore.Timestamp.now();

    // Get all pending invoices with due date
    const invoicesSnapshot = await db.collection('invoices')
      .where('paymentStatus', '==', 'pending')
      .get();

    let updatedCount = 0;
    const batch = db.batch();

    invoicesSnapshot.docs.forEach(doc => {
      const invoiceData = doc.data();
      if (invoiceData.dueDate) {
        const dueDate = invoiceData.dueDate.toDate ? invoiceData.dueDate.toDate() : new Date(invoiceData.dueDate);
        const todayDate = today.toDate();

        // Check if invoice is overdue
        if (dueDate < todayDate) {
          batch.update(doc.ref, {
            paymentStatus: 'overdue',
            updatedAt: today
          });
          updatedCount++;
        }
      }
    });

    if (updatedCount > 0) {
      await batch.commit();
      console.log(`Updated ${updatedCount} overdue invoices`);
    } else {
      console.log('No overdue invoices found');
    }

    return { success: true, updatedCount };
  } catch (error) {
    console.error('Error in checkOverdueInvoices:', error);
    return { success: false, error: error.message };
  }
});

// ============================================
// TRIGGER 5: Backup Firestore data daily
// ============================================
export const backupFirestore = onSchedule('every day 02:00', async (event) => {
  try {
    console.log('Starting daily Firestore backup...');
    
    // Note: Actual backup implementation would use Firebase Admin SDK's export functionality
    // This is a placeholder for the backup logic
    
    const collections = ['users', 'clients', 'projects', 'tasks', 'invoices', 'notifications'];
    const backupData = {};
    
    for (const collectionName of collections) {
      const snapshot = await db.collection(collectionName).get();
      backupData[collectionName] = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
    }

    // Store backup metadata
    await db.collection('backups').add({
      timestamp: admin.firestore.Timestamp.now(),
      collections: collections.length,
      totalDocuments: Object.values(backupData).reduce((sum, docs) => sum + docs.length, 0),
      status: 'completed'
    });

    console.log('Backup completed successfully');
    return { success: true, collections: collections.length };
  } catch (error) {
    console.error('Error in backupFirestore:', error);
    return { success: false, error: error.message };
  }
});

// ============================================
// TRIGGER 6: Calculate and cache analytics daily
// ============================================
export const cacheAnalytics = onSchedule('every day 01:00', async (event) => {
  try {
    console.log('Caching analytics data...');

    const [clientsSnap, projectsSnap, tasksSnap, invoicesSnap, usersSnap] = await Promise.all([
      db.collection('clients').get(),
      db.collection('projects').get(),
      db.collection('tasks').get(),
      db.collection('invoices').get(),
      db.collection('users').get()
    ]);

    const tasks = tasksSnap.docs.map(doc => doc.data());
    const invoices = invoicesSnap.docs.map(doc => doc.data());
    const projects = projectsSnap.docs.map(doc => doc.data());

    const analyticsData = {
      totalClients: clientsSnap.size,
      totalProjects: projectsSnap.size,
      activeProjects: projects.filter(p => p.status !== 'completed').length,
      totalTasks: tasksSnap.size,
      completedTasks: tasks.filter(t => t.status === 'completed').length,
      pendingTasks: tasks.filter(t => t.status === 'pending').length,
      totalInvoices: invoicesSnap.size,
      paidInvoices: invoices.filter(i => i.paymentStatus === 'paid').length,
      totalRevenue: invoices.reduce((sum, inv) => sum + (inv.total || inv.amount || 0), 0),
      paidRevenue: invoices
        .filter(i => i.paymentStatus === 'paid')
        .reduce((sum, inv) => sum + (inv.total || inv.amount || 0), 0),
      totalUsers: usersSnap.size,
      cachedAt: admin.firestore.Timestamp.now()
    };

    // Store cached analytics
    await db.collection('cached_analytics').doc('latest').set(analyticsData);
    console.log('Analytics cached successfully');

    return { success: true, analyticsData };
  } catch (error) {
    console.error('Error in cacheAnalytics:', error);
    return { success: false, error: error.message };
  }
});

// ============================================
// TRIGGER 7: Clean up old notifications
// ============================================
export const cleanupOldNotifications = onSchedule('every day 03:00', async (event) => {
  try {
    console.log('Cleaning up old notifications...');
    
    // Delete notifications older than 30 days
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const cutoffTimestamp = admin.firestore.Timestamp.fromDate(thirtyDaysAgo);

    const oldNotifications = await db.collection('notifications')
      .where('createdAt', '<', cutoffTimestamp)
      .get();

    if (oldNotifications.empty) {
      console.log('No old notifications to delete');
      return { success: true, deletedCount: 0 };
    }

    const batch = db.batch();
    oldNotifications.docs.forEach(doc => {
      batch.delete(doc.ref);
    });

    await batch.commit();
    console.log(`Deleted ${oldNotifications.size} old notifications`);

    return { success: true, deletedCount: oldNotifications.size };
  } catch (error) {
    console.error('Error in cleanupOldNotifications:', error);
    return { success: false, error: error.message };
  }
});
